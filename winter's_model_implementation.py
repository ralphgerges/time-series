# -*- coding: utf-8 -*-
"""Winter's Model Implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gLh6_xM2cHSQN2XMJYfip8H8Wh93GAfP

## Import Libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""## Holt-Winter's Model"""

class WintersModel:
  def __init__(self, alpha, beta, gamma, s):
    self.alpha = alpha
    self.beta = beta
    self.gamma = gamma
    self.s = s

  def train(self, dataset):
    self.dataset = dataset
    self.level = np.zeros(len(dataset))
    self.trend = np.zeros(len(dataset))
    self.seasonality = np.zeros(len(dataset))
    self.forecast = np.zeros(len(dataset))

    #initial values
    self.seasonality[0] = dataset[0] / sum(dataset[:self.s])
    self.level[0] = dataset[0] / self.seasonality[0]
    self.trend[0] = sum([float(dataset[i + self.s] - dataset[i]) for i in range(self.s)]) / self.s
    self.forecast[0] = dataset[0]

    #formulas
    for i in range(1, len(dataset)):
      self.seasonality[i] = dataset[i] / sum(dataset[i//self.s * self.s:(i//self.s + 1) * self.s])
      self.level[i] = self.alpha * (dataset[i] / self.seasonality[i]) + (1 - self.alpha) * (self.level[i - 1] + self.trend[i - 1])
      self.trend[i] = self.beta * (self.level[i] - self.level[i - 1]) + (1 - self.beta) * self.trend[i - 1]
      self.forecast[i] = (self.level[i - 1] + self.trend[i - 1]) * self.seasonality[i]

  #Forecasting
  def predict(self, steps):
    forcasted_values= np.zeros(steps)
    for i in range(steps):
      forcasted_values[i] = (self.level[- 1] + self.trend[- 1]) * self.seasonality[i]
    return forcasted_values

  # Mean Absolute Deviation
  def get_MAD(self):
    mad = sum([abs(self.dataset[i] - self.forecast[i]) for i in range(len(self.dataset))])
    return mad

  # Mean Squared Deviation
  def get_MSD(self):
    msd = sum([(self.dataset[i] - self.forecast[i])**2 for i in range(len(self.dataset))])
    return msd

  # Mean Percentage Deviation(MPD)
  def get_MPD(self):
    mpd = 100 * sum([abs(self.dataset[i] - self.forecast[i])/self.dataset[i] for i in range(len(self.dataset))])
    return mpd

  #Overall Evaluation
  def evaluate(self):
    evaluation = {
       'Mean Absolute Deviation(MAD)' : self.get_MAD(),
       'Mean Squared Deviation(MSD)' : self.get_MSD(),
       'Mean Percentage Deviation(MPD)' : self.get_MPD()
    }
    return evaluation

"""## Testing the model with the 'sales' dataset"""

dataset = pd.read_csv('/sales.csv')
dataset.head()

sales = dataset['Sales'].values

model = WintersModel( alpha=0.2, beta=0.3, gamma=0.002, s= 4)
model.train(dataset= sales)
forecasted_values = model.predict(steps = 15)


details_df = pd.DataFrame({
    'Data': sales,
    'Level': model.level,
    'Seasonality': model.seasonality,
    'Trend': model.trend,
    'Forecast': model.forecast
})


print(details_df)

"""## Model Evaluation"""

evaluation = model.evaluate()
print(evaluation)

"""## Ploting Results"""

def plot_forecast(data, forecast):
    plt.figure(figsize=(10, 6))
    plt.plot(data, linewidth=2, label='Initial Values')
    plt.plot(model.forecast, linewidth=2, label='Forecasted Values')
    plt.plot(range(len(data), len(data) + len(forecast)), forecast, linewidth=2, label='Future Values Forecast')

    # Highlight future period
    plt.axvspan(len(data), len(data) + len(forecast), facecolor='grey', alpha=0.25)

    plt.xlabel('Time')
    plt.ylabel('Sales')
    plt.title('Shampoo Sales and Forecasted Values')
    plt.legend()
    plt.show()


plot_forecast(sales, forecasted_values)

"""##Linear Interpolation"""

class Interpolate:
    def _init_(self, x_list, y_list):
        if any(y - x <= 0 for x, y in zip(x_list, x_list[1:])):
            raise ValueError("x_list must be in strictly ascending order!")
        self.x_list = x_list
        self.y_list = y_list
        intervals = zip(x_list, x_list[1:], y_list, y_list[1:])
        self.slopes = [(y2 - y1) / (x2 - x1) for x1, x2, y1, y2 in intervals]

    def _call_(self, x):
        if not (self.x_list[0] <= x <= self.x_list[-1]):
            raise ValueError("x out of bounds!")
        if x == self.x_list[-1]:
            return self.y_list[-1]
        i = bisect_right(self.x_list, x) - 1
        return self.y_list[i] + self.slopes[i] * (x - self.x_list[i])